import pygame
import heapq
import random
import math
from collections import deque

# Initialize pygame
pygame.init()

# Constants
WIDTH, HEIGHT = 1200, 800
GRID_SIZE = 30
GRID_WIDTH = WIDTH // GRID_SIZE
GRID_HEIGHT = HEIGHT // GRID_SIZE
FPS = 60

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 50, 50)
GREEN = (50, 200, 50)
BLUE = (50, 150, 255)
YELLOW = (255, 255, 0)
PURPLE = (180, 50, 230)
ORANGE = (255, 150, 50)
CYAN = (0, 200, 200)
GRAY = (80, 80, 80)
LIGHT_GRAY = (200, 200, 200)
DARK_GRAY = (40, 40, 40)
BROWN = (120, 70, 20)
ROAD_COLOR = (60, 60, 70)
BUILDING_COLORS = [(100, 80, 60), (90, 90, 100), (80, 100, 80), (100, 70, 90)]
CAR_COLORS = [RED, GREEN, BLUE, YELLOW, PURPLE, ORANGE, CYAN]

# Set up the display
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Advanced Dynamic Traffic Simulation using A* Algorithm")
clock = pygame.time.Clock()

# Load fonts
font_large = pygame.font.SysFont("Arial", 32, bold=True)
font_medium = pygame.font.SysFont("Arial", 24)
font_small = pygame.font.SysFont("Arial", 18)

class TrafficLight:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.state = 0  # 0: red, 1: yellow, 2: green
        self.timer = 0
        self.cycle_times = [180, 30, 150]  # red, yellow, green durations
        
    def update(self):
        self.timer += 1
        if self.timer >= self.cycle_times[self.state]:
            self.timer = 0
            self.state = (self.state + 1) % 3
            
    def draw(self, screen):
        light_radius = GRID_SIZE // 6
        center_x = self.x * GRID_SIZE + GRID_SIZE // 2
        center_y = self.y * GRID_SIZE + GRID_SIZE // 2
        
        # Draw traffic light pole
        pygame.draw.rect(screen, DARK_GRAY, (center_x - 2, center_y, 4, GRID_SIZE // 2))
        
        # Draw traffic light box
        pygame.draw.rect(screen, BLACK, (center_x - light_radius*2, center_y - light_radius*5, 
                                        light_radius*4, light_radius*5.5))
        
        # Draw lights
        colors = [RED, YELLOW, GREEN]
        for i in range(3):
            color = colors[i] if self.state == i else (colors[i][0]//3, colors[i][1]//3, colors[i][2]//3)
            pygame.draw.circle(screen, color, 
                              (center_x, center_y - light_radius*3 + i * light_radius*2), 
                              light_radius)

class Node:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.neighbors = []
        self.is_obstacle = False
        self.is_road = True
        self.traffic_density = 0  # 0 to 1, affects movement cost
        self.base_cost = 1
        self.has_traffic_light = False
        self.traffic_light = None
        
    def __lt__(self, other):
        return False

class Vehicle:
    def __init__(self, start, destination, color, vehicle_type="car"):
        self.x, self.y = start
        self.dest_x, self.dest_y = destination
        self.color = color
        self.path = []
        self.current_node_index = 0
        self.vehicle_type = vehicle_type
        self.speed = random.uniform(0.08, 0.15)
        self.max_speed = self.speed
        
        # Set properties based on vehicle type
        if vehicle_type == "bus":
            self.speed *= 0.7
            self.max_speed = self.speed
            self.size = GRID_SIZE // 1.8
            self.color = (200, 0, 0)  # Red bus
        elif vehicle_type == "truck":
            self.speed *= 0.6
            self.max_speed = self.speed
            self.size = GRID_SIZE // 1.6
            self.color = (100, 100, 100)  # Gray truck
        elif vehicle_type == "emergency":
            self.speed *= 1.5
            self.max_speed = self.speed
            self.size = GRID_SIZE // 2.2
            self.color = (255, 50, 50)  # Bright red
        else:  # car
            self.size = GRID_SIZE // 2.5
            
        self.progress = 0
        self.waiting = 0
        self.path_outdated = False
        self.accident = False
        self.accident_timer = 0
        self.emergency_flash = 0
        
    def update(self, grid):
        if self.accident:
            self.accident_timer -= 1
            self.emergency_flash = (self.emergency_flash + 1) % 10
            if self.accident_timer <= 0:
                self.accident = False
            return
            
        if self.waiting > 0:
            self.waiting -= 1
            return
            
        if not self.path or self.path_outdated:
            self.find_path(grid)
            self.path_outdated = False
            return
            
        if self.current_node_index >= len(self.path):
            # Reached destination, find a new one
            self.find_new_destination(grid)
            return
            
        target_node = self.path[self.current_node_index]
        target_x, target_y = target_node.x * GRID_SIZE + GRID_SIZE // 2, target_node.y * GRID_SIZE + GRID_SIZE // 2
        current_x, current_y = self.x, self.y
        
        # Check for traffic light
        if target_node.has_traffic_light and target_node.traffic_light.state != 2:  # Not green
            self.waiting = 5
            return
        
        # Calculate distance to target
        dx = target_x - current_x
        dy = target_y - current_y
        distance = math.sqrt(dx*dx + dy*dy)
        
        if distance < 5:  # Reached the node
            self.current_node_index += 1
            if self.current_node_index < len(self.path):
                # Add some delay based on traffic density
                self.waiting = int(target_node.traffic_density * 15)
                # Adjust speed based on traffic
                self.speed = self.max_speed * (1 - target_node.traffic_density * 0.7)
                
                # Small chance of accident
                if random.random() < 0.001 and self.vehicle_type != "emergency":
                    self.accident = True
                    self.accident_timer = 200
                    # Increase traffic density significantly
                    grid_x = int(self.x // GRID_SIZE)
                    grid_y = int(self.y // GRID_SIZE)
                    if 0 <= grid_x < GRID_WIDTH and 0 <= grid_y < GRID_HEIGHT:
                        grid[grid_x][grid_y].traffic_density = min(1.0, grid[grid_x][grid_y].traffic_density + 0.5)
        else:
            # Move toward the target
            self.x += (dx / distance) * self.speed * GRID_SIZE
            self.y += (dy / distance) * self.speed * GRID_SIZE
    
    def find_new_destination(self, grid):
        attempts = 0
        while attempts < 20:
            dest_x, dest_y = random.randint(0, GRID_WIDTH-1), random.randint(0, GRID_HEIGHT-1)
            if not grid[dest_x][dest_y].is_obstacle and (int(self.x // GRID_SIZE) != dest_x or int(self.y // GRID_SIZE) != dest_y):
                self.dest_x, self.dest_y = dest_x, dest_y
                self.find_path(grid)
                return
            attempts += 1
    
    def find_path(self, grid):
        start_x, start_y = int(self.x // GRID_SIZE), int(self.y // GRID_SIZE)
        start = (start_x, start_y)
        end = (self.dest_x, self.dest_y)
        
        if (start[0] < 0 or start[0] >= GRID_WIDTH or start[1] < 0 or start[1] >= GRID_HEIGHT or
            end[0] < 0 or end[0] >= GRID_WIDTH or end[1] < 0 or end[1] >= GRID_HEIGHT):
            return
            
        # A* algorithm
        open_set = []
        closed_set = set()
        came_from = {}
        
        g_score = {(x, y): float('inf') for x in range(GRID_WIDTH) for y in range(GRID_HEIGHT)}
        g_score[start] = 0
        
        f_score = {(x, y): float('inf') for x in range(GRID_WIDTH) for y in range(GRID_HEIGHT)}
        f_score[start] = heuristic(start, end)
        
        heapq.heappush(open_set, (f_score[start], start))
        
        while open_set:
            current = heapq.heappop(open_set)[1]
            
            if current == end:
                # Reconstruct path
                self.path = []
                while current in came_from:
                    self.path.append(grid[current[0]][current[1]])
                    current = came_from[current]
                self.path.reverse()
                self.current_node_index = 0
                return
                
            closed_set.add(current)
            
            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, 1), (1, -1), (-1, -1)]:
                neighbor = (current[0] + dx, current[1] + dy)
                
                if (neighbor[0] < 0 or neighbor[0] >= GRID_WIDTH or 
                    neighbor[1] < 0 or neighbor[1] >= GRID_HEIGHT or 
                    grid[neighbor[0]][neighbor[1]].is_obstacle or 
                    neighbor in closed_set):
                    continue
                    
                # Calculate tentative g_score with traffic consideration
                base_cost = 1.4 if dx != 0 and dy != 0 else 1.0  # Diagonal movement cost
                traffic_cost = grid[neighbor[0]][neighbor[1]].traffic_density * 8
                
                # Emergency vehicles care less about traffic
                if self.vehicle_type == "emergency":
                    traffic_cost *= 0.3
                    
                tentative_g_score = g_score[current] + base_cost + traffic_cost
                
                if tentative_g_score < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)
                    if (f_score[neighbor], neighbor) not in open_set:
                        heapq.heappush(open_set, (f_score[neighbor], neighbor))
        
    def draw(self, screen):
        if self.accident and self.emergency_flash < 5:
            # Flash during accident
            return
            
        # Draw vehicle with a slight shadow
        pygame.draw.circle(screen, DARK_GRAY, (int(self.x) + 2, int(self.y) + 2), self.size)
        
        if self.vehicle_type == "bus":
            # Draw bus as rectangle
            pygame.draw.rect(screen, self.color, 
                            (int(self.x) - self.size, int(self.y) - self.size/2, 
                             self.size*2, self.size))
            pygame.draw.rect(screen, (200, 200, 200), 
                            (int(self.x) - self.size*0.7, int(self.y) - self.size*0.4, 
                             self.size*1.4, self.size*0.8))
        elif self.vehicle_type == "truck":
            # Draw truck as rectangle with cab
            pygame.draw.rect(screen, self.color, 
                            (int(self.x) - self.size, int(self.y) - self.size/2, 
                             self.size*2, self.size))
            pygame.draw.rect(screen, (50, 50, 50), 
                            (int(self.x) - self.size*0.8, int(self.y) - self.size*0.4, 
                             self.size*0.6, self.size*0.8))
        elif self.vehicle_type == "emergency":
            # Draw emergency vehicle with flashing lights
            pygame.draw.rect(screen, self.color, 
                            (int(self.x) - self.size, int(self.y) - self.size/2, 
                             self.size*2, self.size))
            # Flashing lights
            if pygame.time.get_ticks() % 500 < 250:
                pygame.draw.rect(screen, BLUE, 
                                (int(self.x) - self.size*0.8, int(self.y) - self.size*0.8, 
                                 self.size*0.5, self.size*0.5))
                pygame.draw.rect(screen, RED, 
                                (int(self.x) + self.size*0.3, int(self.y) - self.size*0.8, 
                                 self.size*0.5, self.size*0.5))
        else:
            # Draw car as circle
            pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.size)
        
        # Draw a direction indicator
        if self.current_node_index < len(self.path) and not self.accident:
            target_node = self.path[self.current_node_index]
            target_x, target_y = target_node.x * GRID_SIZE + GRID_SIZE // 2, target_node.y * GRID_SIZE + GRID_SIZE // 2
            dx, dy = target_x - self.x, target_y - self.y
            dist = math.sqrt(dx*dx + dy*dy)
            if dist > 0:
                dx, dy = dx/dist, dy/dist
                pygame.draw.line(screen, WHITE, 
                                (self.x, self.y),
                                (self.x + dx * self.size * 0.8, self.y + dy * self.size * 0.8), 2)

def heuristic(a, b):
    # Euclidean distance
    return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)

def create_grid():
    grid = [[Node(x, y) for y in range(GRID_HEIGHT)] for x in range(GRID_WIDTH)]
    traffic_lights = []
    
    # Create roads and buildings
    for x in range(GRID_WIDTH):
        for y in range(GRID_HEIGHT):
            # Make some nodes obstacles (buildings)
            if random.random() < 0.25:  # 25% chance of being a building
                grid[x][y].is_obstacle = True
                grid[x][y].is_road = False
            else:
                # Random traffic density
                grid[x][y].traffic_density = random.uniform(0, 0.3)
    
    # Create main roads with traffic lights
    for i in range(GRID_WIDTH):
        if not grid[i][GRID_HEIGHT//3].is_obstacle:
            grid[i][GRID_HEIGHT//3].traffic_density = 0.05
            if i % 5 == 0:  # Add traffic lights at intervals
                grid[i][GRID_HEIGHT//3].has_traffic_light = True
                traffic_light = TrafficLight(i, GRID_HEIGHT//3)
                grid[i][GRID_HEIGHT//3].traffic_light = traffic_light
                traffic_lights.append(traffic_light)
                
        if not grid[i][2*GRID_HEIGHT//3].is_obstacle:
            grid[i][2*GRID_HEIGHT//3].traffic_density = 0.05
            if i % 5 == 2:  # Staggered traffic lights
                grid[i][2*GRID_HEIGHT//3].has_traffic_light = True
                traffic_light = TrafficLight(i, 2*GRID_HEIGHT//3)
                grid[i][2*GRID_HEIGHT//3].traffic_light = traffic_light
                traffic_lights.append(traffic_light)
            
    for i in range(GRID_HEIGHT):
        if not grid[GRID_WIDTH//3][i].is_obstacle:
            grid[GRID_WIDTH//3][i].traffic_density = 0.05
            if i % 5 == 0:
                grid[GRID_WIDTH//3][i].has_traffic_light = True
                traffic_light = TrafficLight(GRID_WIDTH//3, i)
                grid[GRID_WIDTH//3][i].traffic_light = traffic_light
                traffic_lights.append(traffic_light)
                
        if not grid[2*GRID_WIDTH//3][i].is_obstacle:
            grid[2*GRID_WIDTH//3][i].traffic_density = 0.05
            if i % 5 == 2:
                grid[2*GRID_WIDTH//3][i].has_traffic_light = True
                traffic_light = TrafficLight(2*GRID_WIDTH//3, i)
                grid[2*GRID_WIDTH//3][i].traffic_light = traffic_light
                traffic_lights.append(traffic_light)
    
    return grid, traffic_lights

def draw_grid(grid):
    for x in range(GRID_WIDTH):
        for y in range(GRID_HEIGHT):
            rect = pygame.Rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE)
            if grid[x][y].is_obstacle:
                # Draw building
                color = random.choice(BUILDING_COLORS)
                pygame.draw.rect(screen, color, rect)
                # Draw windows
                if GRID_SIZE > 5:
                    for i in range(0, GRID_SIZE, GRID_SIZE//3):
                        for j in range(0, GRID_SIZE, GRID_SIZE//3):
                            if random.random() < 0.7:  # Some windows are lit
                                pygame.draw.rect(screen, YELLOW if random.random() < 0.8 else BLUE, 
                                               (x * GRID_SIZE + i + 1, y * GRID_SIZE + j + 1, 
                                                GRID_SIZE//3 - 2, GRID_SIZE//3 - 2))
            else:
                # Draw road with color based on traffic density
                color_value = int(60 + grid[x][y].traffic_density * 100)
                color_value = min(160, max(60, color_value))
                pygame.draw.rect(screen, (color_value, color_value, color_value), rect)
                
                # Draw road markings on main roads
                if grid[x][y].traffic_density < 0.1 and (y % 3 == 0 or x % 3 == 0):
                    pygame.draw.rect(screen, YELLOW, 
                                    (x * GRID_SIZE + GRID_SIZE//2 - 1, y * GRID_SIZE + GRID_SIZE//2 - 1, 2, 2))
            
            # Draw grid lines
            pygame.draw.rect(screen, DARK_GRAY, rect, 1)

def draw_ui(vehicles, paused, show_paths, show_traffic, time_multiplier):
    # Draw background for UI
    pygame.draw.rect(screen, (40, 40, 50, 200), (0, 0, WIDTH, 50))
    pygame.draw.rect(screen, (40, 40, 50, 200), (0, HEIGHT - 50, WIDTH, 50))
    
    # Draw title
    title = font_large.render("Advanced Traffic Simulation using A* Algorithm", True, YELLOW)
    screen.blit(title, (WIDTH // 2 - title.get_width() // 2, 10))
    
    # Draw controls
    controls = font_small.render("Controls: R - Reset | P - Pause | T - Toggle Paths | D - Toggle Traffic Data | +/- - Add/Remove Vehicles | 1/2 - Time Speed", True, LIGHT_GRAY)
    screen.blit(controls, (WIDTH // 2 - controls.get_width() // 2, HEIGHT - 40))
    
    # Draw stats
    car_count = sum(1 for v in vehicles if v.vehicle_type == "car")
    bus_count = sum(1 for v in vehicles if v.vehicle_type == "bus")
    truck_count = sum(1 for v in vehicles if v.vehicle_type == "truck")
    emergency_count = sum(1 for v in vehicles if v.vehicle_type == "emergency")
    accident_count = sum(1 for v in vehicles if v.accident)
    
    stats = font_medium.render(f"Vehicles: {len(vehicles)} (C:{car_count} B:{bus_count} T:{truck_count} E:{emergency_count}) | Accidents: {accident_count} | {'Paused' if paused else 'Running'} | Speed: {time_multiplier}x", True, GREEN)
    screen.blit(stats, (10, HEIGHT - 40))
    
    # Draw legend
    if show_traffic:
        legend_x = WIDTH - 200
        pygame.draw.rect(screen, (40, 40, 50, 200), (legend_x, 10, 190, 130))
        pygame.draw.rect(screen, WHITE, (legend_x, 10, 190, 130), 2)
        
        title = font_small.render("Traffic Density Legend", True, YELLOW)
        screen.blit(title, (legend_x + 10, 15))
        
        # Draw gradient
        for i in range(100):
            color_val = 60 + int(i * 0.8)
            pygame.draw.rect(screen, (color_val, color_val, color_val), 
                            (legend_x + 10 + i, 45, 1, 15))
        
        # Labels
        screen.blit(font_small.render("Low", True, WHITE), (legend_x + 10, 65))
        screen.blit(font_small.render("High", True, WHITE), (legend_x + 90, 65))
        
        # Vehicle types
        y_pos = 85
        for vtype, color in [("Car", RED), ("Bus", (200, 0, 0)), ("Truck", (100, 100, 100)), ("Emergency", (255, 50, 50))]:
            pygame.draw.rect(screen, color, (legend_x + 10, y_pos, 10, 10))
            screen.blit(font_small.render(vtype, True, WHITE), (legend_x + 25, y_pos - 2))
            y_pos += 15

def draw_paths(vehicles):
    for vehicle in vehicles:
        if vehicle.path and len(vehicle.path) > 1:
            for i in range(len(vehicle.path) - 1):
                start_x = vehicle.path[i].x * GRID_SIZE + GRID_SIZE // 2
                start_y = vehicle.path[i].y * GRID_SIZE + GRID_SIZE // 2
                end_x = vehicle.path[i + 1].x * GRID_SIZE + GRID_SIZE // 2
                end_y = vehicle.path[i + 1].y * GRID_SIZE + GRID_SIZE // 2
                
                # Draw path with gradient color (darker for higher traffic)
                traffic = vehicle.path[i].traffic_density
                color = (255, int(255 * (1 - traffic)), 0)
                pygame.draw.line(screen, color, (start_x, start_y), (end_x, end_y), 2)

def draw_traffic_data(grid):
    for x in range(GRID_WIDTH):
        for y in range(GRID_HEIGHT):
            if not grid[x][y].is_obstacle and grid[x][y].traffic_density > 0.1:
                # Draw traffic density percentage
                density_text = font_small.render(f"{int(grid[x][y].traffic_density * 100)}%", True, WHITE)
                screen.blit(density_text, (x * GRID_SIZE + 5, y * GRID_SIZE + 5))

def main():
    grid, traffic_lights = create_grid()
    vehicles = []
    paused = False
    show_paths = True
    show_traffic_data = False
    time_multiplier = 1.0
    
    # Create initial vehicles of different types
    for _ in range(15):
        while True:
            x, y = random.randint(0, GRID_WIDTH-1), random.randint(0, GRID_HEIGHT-1)
            if not grid[x][y].is_obstacle:
                break
        while True:
            dest_x, dest_y = random.randint(0, GRID_WIDTH-1), random.randint(0, GRID_HEIGHT-1)
            if not grid[dest_x][dest_y].is_obstacle and (x != dest_x or y != dest_y):
                break
        
        vehicle_type = random.choices(["car", "bus", "truck", "emergency"], weights=[10, 2, 2, 1])[0]
        vehicles.append(Vehicle((x * GRID_SIZE + GRID_SIZE // 2, y * GRID_SIZE + GRID_SIZE // 2), 
                               (dest_x, dest_y), random.choice(CAR_COLORS), vehicle_type))
    
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_r:
                    # Reset simulation
                    grid, traffic_lights = create_grid()
                    vehicles = []
                    for _ in range(15):
                        while True:
                            x, y = random.randint(0, GRID_WIDTH-1), random.randint(0, GRID_HEIGHT-1)
                            if not grid[x][y].is_obstacle:
                                break
                        while True:
                            dest_x, dest_y = random.randint(0, GRID_WIDTH-1), random.randint(0, GRID_HEIGHT-1)
                            if not grid[dest_x][dest_y].is_obstacle and (x != dest_x or y != dest_y):
                                break
                        vehicle_type = random.choices(["car", "bus", "truck", "emergency"], weights=[10, 2, 2, 1])[0]
                        vehicles.append(Vehicle((x * GRID_SIZE + GRID_SIZE // 2, y * GRID_SIZE + GRID_SIZE // 2), 
                                               (dest_x, dest_y), random.choice(CAR_COLORS), vehicle_type))
                elif event.key == pygame.K_p:
                    # Toggle pause
                    paused = not paused
                elif event.key == pygame.K_t:
                    # Toggle path visibility
                    show_paths = not show_paths
                elif event.key == pygame.K_d:
                    # Toggle traffic data
                    show_traffic_data = not show_traffic_data
                elif event.key == pygame.K_PLUS or event.key == pygame.K_EQUALS:
                    # Add vehicle
                    while True:
                        x, y = random.randint(0, GRID_WIDTH-1), random.randint(0, GRID_HEIGHT-1)
                        if not grid[x][y].is_obstacle:
                            break
                    while True:
                        dest_x, dest_y = random.randint(0, GRID_WIDTH-1), random.randint(0, GRID_HEIGHT-1)
                        if not grid[dest_x][dest_y].is_obstacle and (x != dest_x or y != dest_y):
                            break
                    vehicle_type = random.choices(["car", "bus", "truck", "emergency"], weights=[10, 2, 2, 1])[0]
                    vehicles.append(Vehicle((x * GRID_SIZE + GRID_SIZE // 2, y * GRID_SIZE + GRID_SIZE // 2), 
                                           (dest_x, dest_y), random.choice(CAR_COLORS), vehicle_type))
                elif event.key == pygame.K_MINUS:
                    # Remove vehicle
                    if vehicles:
                        vehicles.pop()
                elif event.key == pygame.K_1:
                    time_multiplier = 1.0
                elif event.key == pygame.K_2:
                    time_multiplier = 2.0
        
        if not paused:
            # Update traffic lights
            for _ in range(int(time_multiplier)):
                for light in traffic_lights:
                    light.update()
            
            # Update traffic density based on vehicle positions
            for x in range(GRID_WIDTH):
                for y in range(GRID_HEIGHT):
                    if not grid[x][y].is_obstacle:
                        # Gradually reduce traffic density
                        grid[x][y].traffic_density *= 0.97
            
            # Update vehicles
            for _ in range(int(time_multiplier)):
                for vehicle in vehicles:
                    vehicle.update(grid)
                    
                    # Update traffic density where vehicles are
                    grid_x = int(vehicle.x // GRID_SIZE)
                    grid_y = int(vehicle.y // GRID_SIZE)
                    if 0 <= grid_x < GRID_WIDTH and 0 <= grid_y < GRID_HEIGHT and not grid[grid_x][grid_y].is_obstacle:
                        density_increase = 0.05
                        if vehicle.vehicle_type == "bus" or vehicle.vehicle_type == "truck":
                            density_increase *= 2
                        grid[grid_x][grid_y].traffic_density = min(1.0, grid[grid_x][grid_y].traffic_density + density_increase)
        
        # Draw everything
        screen.fill(DARK_GRAY)
        draw_grid(grid)
        
        # Draw traffic lights
        for light in traffic_lights:
            light.draw(screen)
        
        # Draw paths if enabled
        if show_paths:
            draw_paths(vehicles)
        
        # Draw traffic data if enabled
        if show_traffic_data:
            draw_traffic_data(grid)
        
        # Draw destinations for vehicles
        for vehicle in vehicles:
            pygame.draw.rect(screen, GREEN, 
                            (vehicle.dest_x * GRID_SIZE + 2, vehicle.dest_y * GRID_SIZE + 2, 
                             GRID_SIZE - 4, GRID_SIZE - 4), 2)
        
        # Draw vehicles
        for vehicle in vehicles:
            vehicle.draw(screen)
        
        # Draw UI
        draw_ui(vehicles, paused, show_paths, show_traffic_data, time_multiplier)
        
        pygame.display.flip()
        clock.tick(FPS)
    
    pygame.quit()

if __name__ == "__main__":
    main()
