import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, IsolationForest
from sklearn.svm import SVC
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc, precision_recall_curve
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.cluster import DBSCAN
import pickle
import os
import pefile
import math
import hashlib
import threading
import time
from datetime import datetime
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
from PIL import Image, ImageTk
import matplotlib
matplotlib.use('TkAgg')
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.figure import Figure
import sqlite3
import json
import requests
from io import BytesIO
import zipfile
import tempfile
import warnings
warnings.filterwarnings('ignore')

# Feature extraction functions
def calculate_entropy(data):
    """Calculate the entropy of a byte array"""
    if not data:
        return 0
    
    entropy = 0
    for x in range(256):
        p_x = float(data.count(x))/len(data)
        if p_x > 0:
            entropy += - p_x * math.log(p_x, 2)
    
    return entropy

def calculate_file_hash(file_path, algorithm='sha256'):
    """Calculate file hash using specified algorithm"""
    hash_func = hashlib.new(algorithm)
    try:
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_func.update(chunk)
        return hash_func.hexdigest()
    except:
        return None

def extract_pe_features(file_path):
    """Extract features from Portable Executable (PE) files"""
    try:
        pe = pefile.PE(file_path)
        
        features = {}
        
        # Basic file info
        file_size = os.path.getsize(file_path)
        features['FileSize'] = file_size
        features['FileHash'] = calculate_file_hash(file_path)
        
        # Extract header information
        features['Machine'] = pe.FILE_HEADER.Machine
        features['NumberOfSections'] = pe.FILE_HEADER.NumberOfSections
        features['TimeDateStamp'] = pe.FILE_HEADER.TimeDateStamp
        features['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
        features['Characteristics'] = pe.FILE_HEADER.Characteristics
        
        # Extract optional header information
        features['Magic'] = pe.OPTIONAL_HEADER.Magic
        features['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
        features['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
        features['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
        features['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
        features['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
        features['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
        features['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
        features['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
        features['SectionAlignment'] = pe.OPTIONAL_HEADER.SectionAlignment
        features['FileAlignment'] = pe.OPTIONAL_HEADER.FileAlignment
        features['MajorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
        features['MinorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
        features['MajorImageVersion'] = pe.OPTIONAL_HEADER.MajorImageVersion
        features['MinorImageVersion'] = pe.OPTIONAL_HEADER.MinorImageVersion
        features['MajorSubsystemVersion'] = pe.OPTIONAL_HEADER.MajorSubsystemVersion
        features['MinorSubsystemVersion'] = pe.OPTIONAL_HEADER.MinorSubsystemVersion
        features['SizeOfImage'] = pe.OPTIONAL_HEADER.SizeOfImage
        features['SizeOfHeaders'] = pe.OPTIONAL_HEADER.SizeOfHeaders
        features['CheckSum'] = pe.OPTIONAL_HEADER.CheckSum
        features['Subsystem'] = pe.OPTIONAL_HEADER.Subsystem
        features['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics
        features['SizeOfStackReserve'] = pe.OPTIONAL_HEADER.SizeOfStackReserve
        features['SizeOfStackCommit'] = pe.OPTIONAL_HEADER.SizeOfStackCommit
        features['SizeOfHeapReserve'] = pe.OPTIONAL_HEADER.SizeOfHeapReserve
        features['SizeOfHeapCommit'] = pe.OPTIONAL_HEADER.SizeOfHeapCommit
        features['LoaderFlags'] = pe.OPTIONAL_HEADER.LoaderFlags
        features['NumberOfRvaAndSizes'] = pe.OPTIONAL_HEADER.NumberOfRvaAndSizes
        
        # Section information
        sections = pe.sections
        executable_sections = [section for section in sections if section.Characteristics & 0x20000000]
        features['NumberOfExecutableSections'] = len(executable_sections)
        
        # Calculate entropy of each section
        entropy_list = []
        for section in pe.sections:
            data = section.get_data()
            if len(data) > 0:
                entropy = calculate_entropy(data)
                entropy_list.append(entropy)
        
        features['MaxSectionEntropy'] = max(entropy_list) if entropy_list else 0
        features['MinSectionEntropy'] = min(entropy_list) if entropy_list else 0
        features['AvgSectionEntropy'] = sum(entropy_list)/len(entropy_list) if entropy_list else 0
        
        # Import Table analysis
        features['ImportCount'] = 0
        features['SuspiciousImports'] = 0
        
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            features['ImportCount'] = len(pe.DIRECTORY_ENTRY_IMPORT)
            
            # Count suspicious imports
            common_suspicious_apis = [
                'VirtualAlloc', 'VirtualProtect', 'CreateRemoteThread',
                'WriteProcessMemory', 'LoadLibrary', 'GetProcAddress',
                'SetWindowsHookEx', 'RegisterHotKey', 'keybd_event',
                'mouse_event', 'GetAsyncKeyState', 'GetForegroundWindow',
                'URLDownloadToFile', 'ShellExecute', 'WinExec'
            ]
            
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                for imp in entry.imports:
                    if imp.name and any(api in imp.name.decode().lower() for api in common_suspicious_apis):
                        features['SuspiciousImports'] += 1
        
        # Export Table analysis
        features['ExportCount'] = 0
        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            features['ExportCount'] = len(pe.DIRECTORY_ENTRY_EXPORT.symbols)
        
        # Resource analysis
        features['ResourceCount'] = 0
        if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
            features['ResourceCount'] = len(pe.DIRECTORY_ENTRY_RESOURCE.entries)
        
        pe.close()
        return features
        
    except Exception as e:
        print(f"Error processing {file_path}: {str(e)}")
        return None

# Database handler
class DatabaseHandler:
    def __init__(self, db_path="malware_detector.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialize the database with required tables"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Scan history table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS scan_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,
            file_path TEXT,
            file_name TEXT,
            file_size INTEGER,
            file_hash TEXT,
            result TEXT,
            confidence REAL,
            features TEXT
        )
        ''')
        
        # Model storage table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS models (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            timestamp TEXT,
            model_data BLOB,
            performance_metrics TEXT
        )
        ''')
        
        # Whitelist/Blacklist table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS file_trust_list (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            file_hash TEXT UNIQUE,
            trust_level TEXT,
            reason TEXT,
            added_date TEXT
        )
        ''')
        
        conn.commit()
        conn.close()
    
    def save_scan_result(self, result):
        """Save a scan result to the database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        INSERT INTO scan_history 
        (timestamp, file_path, file_name, file_size, file_hash, result, confidence, features)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            result['timestamp'],
            result['file_path'],
            result['file_name'],
            result['file_size'],
            result['file_hash'],
            result['result'],
            result['confidence'],
            json.dumps(result['features'])
        ))
        
        conn.commit()
        conn.close()
    
    def get_scan_history(self, limit=100):
        """Retrieve scan history from database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        SELECT timestamp, file_name, result, confidence, file_hash, file_path
        FROM scan_history 
        ORDER BY timestamp DESC 
        LIMIT ?
        ''', (limit,))
        
        results = cursor.fetchall()
        conn.close()
        
        return [{
            'timestamp': r[0],
            'file_name': r[1],
            'result': r[2],
            'confidence': r[3],
            'file_hash': r[4],
            'file_path': r[5]
        } for r in results]
    
    def get_scan_details(self, file_hash):
        """Get detailed scan results for a specific file hash"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        SELECT * FROM scan_history WHERE file_hash = ?
        ''', (file_hash,))
        
        result = cursor.fetchone()
        conn.close()
        
        if result:
            return {
                'id': result[0],
                'timestamp': result[1],
                'file_path': result[2],
                'file_name': result[3],
                'file_size': result[4],
                'file_hash': result[5],
                'result': result[6],
                'confidence': result[7],
                'features': json.loads(result[8]) if result[8] else {}
            }
        return None

# Malware Detection Class
class MalwareDetector:
    def __init__(self):
        self.model = None
        self.scaler = StandardScaler()
        self.feature_columns = None
        self.models = {}
        self.current_model = None
        self.db = DatabaseHandler()
    
    def create_synthetic_data(self, num_samples=1000):
        """Create synthetic data for demonstration purposes"""
        features = []
        labels = []
        
        for i in range(num_samples):
            # Simulate features of benign and malicious files
            if i < num_samples // 2:  # Benign files
                features.append({
                    'NumberOfSections': np.random.randint(3, 7),
                    'SizeOfCode': np.random.randint(1000, 50000),
                    'SizeOfInitializedData': np.random.randint(1000, 50000),
                    'AddressOfEntryPoint': np.random.randint(1000, 50000),
                    'MaxSectionEntropy': np.random.uniform(4.0, 6.0),
                    'Subsystem': np.random.choice([2, 3]),
                    'DllCharacteristics': np.random.randint(0, 1000),
                    'ImportCount': np.random.randint(5, 20),
                    'SuspiciousImports': np.random.randint(0, 2),
                    'FileSize': np.random.randint(10000, 1000000),
                    'ExportCount': np.random.randint(0, 5),
                    'ResourceCount': np.random.randint(1, 10)
                })
                labels.append(0)  # Benign
            else:  # Malicious files
                features.append({
                    'NumberOfSections': np.random.randint(6, 12),
                    'SizeOfCode': np.random.randint(50000, 200000),
                    'SizeOfInitializedData': np.random.randint(50000, 200000),
                    'AddressOfEntryPoint': np.random.randint(50000, 200000),
                    'MaxSectionEntropy': np.random.uniform(6.5, 8.0),
                    'Subsystem': np.random.choice([2, 3, 5, 7, 9, 14]),
                    'DllCharacteristics': np.random.randint(1000, 5000),
                    'ImportCount': np.random.randint(20, 50),
                    'SuspiciousImports': np.random.randint(3, 10),
                    'FileSize': np.random.randint(500000, 5000000),
                    'ExportCount': np.random.randint(0, 2),
                    'ResourceCount': np.random.randint(0, 5)
                })
                labels.append(1)  # Malicious
        
        return pd.DataFrame(features), labels
    
    def train_models(self, features_df, labels):
        """Train multiple machine learning models"""
        # Split the data
        X_train, X_test, y_train, y_test = train_test_split(
            features_df, labels, test_size=0.2, random_state=42, stratify=labels
        )
        
        # Scale the features
        X_train_scaled = self.scaler.fit_transform(X_train)
        X_test_scaled = self.scaler.transform(X_test)
        
        # Save feature columns for later use
        self.feature_columns = list(features_df.columns)
        
        # Define models to train
        models = {
            'Random Forest': RandomForestClassifier(n_estimators=100, random_state=42),
            'Gradient Boosting': GradientBoostingClassifier(n_estimators=100, random_state=42),
            'SVM': SVC(probability=True, random_state=42),
            'Isolation Forest': IsolationForest(contamination=0.1, random_state=42)
        }
        
        results = {}
        
        # Train each model
        for name, model in models.items():
            print(f"Training {name}...")
            
            # Handle Isolation Forest differently (unsupervised)
            if name == 'Isolation Forest':
                # Convert labels to fit isolation forest (1 for normal, -1 for anomaly)
                y_train_if = np.ones_like(y_train)
                y_train_if[y_train == 1] = -1  # Mark malware as anomalies
                
                model.fit(X_train_scaled)
                train_score = model.score(X_train_scaled, y_train_if)
                
                # Predict on test set
                y_pred_if = model.predict(X_test_scaled)
                # Convert back to binary classification (0 for benign, 1 for malware)
                y_pred = np.where(y_pred_if == -1, 1, 0)
                test_score = np.mean(y_pred == y_test)
                
                # Get prediction probabilities (not directly available in IsolationForest)
                y_proba = model.decision_function(X_test_scaled)
                # Convert to probability-like scores
                y_proba = 1 / (1 + np.exp(-y_proba))
                
            else:
                model.fit(X_train_scaled, y_train)
                train_score = model.score(X_train_scaled, y_train)
                test_score = model.score(X_test_scaled, y_test)
                y_pred = model.predict(X_test_scaled)
                y_proba = model.predict_proba(X_test_scaled)[:, 1] if hasattr(model, 'predict_proba') else None
            
            # Store results
            results[name] = {
                'model': model,
                'train_score': train_score,
                'test_score': test_score,
                'y_pred': y_pred,
                'y_proba': y_proba,
                'cv_score': cross_val_score(model, X_train_scaled, y_train, cv=5).mean() if name != 'Isolation Forest' else None
            }
            
            print(f"{name} - Training Accuracy: {train_score:.4f}, Testing Accuracy: {test_score:.4f}")
        
        # Set the first model as current
        self.current_model = list(models.keys())[0]
        self.model = models[self.current_model]
        
        return results, X_test_scaled, y_test
    
    def predict(self, file_path):
        """Predict if a file is malicious"""
        if self.model is None:
            raise Exception("Model not trained. Please train the model first.")
        
        # Check if file is in trust list first
        file_hash = calculate_file_hash(file_path)
        if file_hash and self.is_file_trusted(file_hash):
            return {
                'result': 'Benign',
                'confidence': 99.9,
                'features': {},
                'file_path': file_path,
                'file_name': os.path.basename(file_path),
                'file_size': os.path.getsize(file_path),
                'file_hash': file_hash,
                'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                'trust_list': True
            }
        
        # Extract features from the file
        features = extract_pe_features(file_path)
        if features is None:
            return {"error": "Could not extract features from file"}
        
        # Convert to dataframe with the same columns as training data
        features_df = pd.DataFrame([features])
        
        # Ensure we have all columns used during training
        for col in self.feature_columns:
            if col not in features_df.columns:
                features_df[col] = 0
        
        # Reorder columns to match training data
        features_df = features_df[self.feature_columns]
        
        # Scale the features
        features_scaled = self.scaler.transform(features_df)
        
        # Make prediction
        if self.current_model == 'Isolation Forest':
            prediction = self.model.predict(features_scaled)
            # Convert isolation forest prediction (-1 for anomaly, 1 for normal) to (1 for malware, 0 for benign)
            prediction = np.where(prediction == -1, 1, 0)
            # Get anomaly score and convert to probability
            anomaly_score = self.model.decision_function(features_scaled)
            probability = 1 / (1 + np.exp(-anomaly_score))
            confidence = probability[0] if prediction[0] == 1 else 1 - probability[0]
        else:
            prediction = self.model.predict(features_scaled)
            probability = self.model.predict_proba(features_scaled)
            confidence = probability[0][1] if prediction[0] == 1 else probability[0][0]
        
        result = "Malicious" if prediction[0] == 1 else "Benign"
        
        return {
            'result': result,
            'confidence': confidence * 100,
            'features': features,
            'file_path': file_path,
            'file_name': os.path.basename(file_path),
            'file_size': features.get('FileSize', 0),
            'file_hash': features.get('FileHash', 'N/A'),
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'trust_list': False
        }
    
    def is_file_trusted(self, file_hash):
        """Check if a file is in the trust list"""
        conn = sqlite3.connect(self.db.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        SELECT trust_level FROM file_trust_list WHERE file_hash = ?
        ''', (file_hash,))
        
        result = cursor.fetchone()
        conn.close()
        
        return result is not None and result[0] == 'trusted'
    
    def add_to_trust_list(self, file_hash, reason="User added"):
        """Add a file to the trust list"""
        conn = sqlite3.connect(self.db.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
            INSERT OR REPLACE INTO file_trust_list (file_hash, trust_level, reason, added_date)
            VALUES (?, ?, ?, ?)
            ''', (file_hash, 'trusted', reason, datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
            
            conn.commit()
            conn.close()
            return True
        except:
            conn.close()
            return False
    
    def set_model(self, model_name):
        """Set the current model to use for predictions"""
        if model_name in self.models:
            self.current_model = model_name
            self.model = self.models[model_name]
            return True
        return False
    
    def save_model(self, file_path):
        """Save the trained model to a file"""
        if self.model is None:
            raise Exception("No model to save. Please train the model first.")
        
        with open(file_path, 'wb') as f:
            pickle.dump({
                'models': self.models,
                'scaler': self.scaler,
                'feature_columns': self.feature_columns,
                'current_model': self.current_model
            }, f)
        
        print(f"Model saved to {file_path}")
    
    def load_model(self, file_path):
        """Load a trained model from a file"""
        with open(file_path, 'rb') as f:
            data = pickle.load(f)
        
        self.models = data['models']
        self.scaler = data['scaler']
        self.feature_columns = data['feature_columns']
        self.current_model = data['current_model']
        self.model = self.models[self.current_model]
        
        print(f"Model loaded from {file_path}")

# GUI Application
class MalwareDetectorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Advanced AI Malware Detection System")
        self.root.geometry("1200x800")
        self.root.minsize(1000, 700)
        
        # Initialize detector
        self.detector = MalwareDetector()
        self.scan_history = []
        self.current_scan_results = []
        
        # Setup styles
        self.setup_styles()
        
        # Create GUI
        self.create_gui()
        
        # Load default model or train on startup
        self.load_or_train_model()
        
        # Load scan history
        self.load_scan_history()
    
    def setup_styles(self):
        """Configure ttk styles"""
        style = ttk.Style()
        style.theme_use('clam')
        
        # Configure colors
        self.bg_color = "#f5f5f5"
        self.accent_color = "#2c3e50"
        self.warning_color = "#e74c3c"
        self.safe_color = "#27ae60"
        self.secondary_color = "#3498db"
        
        style.configure('TFrame', background=self.bg_color)
        style.configure('TLabel', background=self.bg_color, font=('Segoe UI', 10))
        style.configure('Title.TLabel', background=self.bg_color, font=('Segoe UI', 18, 'bold'))
        style.configure('Subtitle.TLabel', background=self.bg_color, font=('Segoe UI', 12, 'bold'))
        style.configure('TButton', font=('Segoe UI', 10))
        style.configure('Accent.TButton', background=self.accent_color, foreground='white')
        style.configure('Warning.TButton', background=self.warning_color, foreground='white')
        style.configure('Safe.TButton', background=self.safe_color, foreground='white')
        style.configure('Secondary.TButton', background=self.secondary_color, foreground='white')
        style.configure('TNotebook', background=self.bg_color)
        style.configure('TNotebook.Tab', font=('Segoe UI', 10, 'bold'))
        style.configure('Header.TLabel', font=('Segoe UI', 11, 'bold'))
        
        self.root.configure(background=self.bg_color)
    
    def create_gui(self):
        """Create the main GUI layout"""
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # Header
        header_frame = ttk.Frame(main_frame)
        header_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Logo and title
        logo_label = ttk.Label(header_frame, text="🛡️", font=('Segoe UI', 24))
        logo_label.grid(row=0, column=0, padx=(0, 10))
        
        title_label = ttk.Label(header_frame, text="Advanced AI Malware Detection System", style='Title.TLabel')
        title_label.grid(row=0, column=1, sticky=tk.W)
        
        # Status label
        self.status_var = tk.StringVar()
        self.status_var.set("Ready")
        status_label = ttk.Label(header_frame, textvariable=self.status_var, style='Subtitle.TLabel')
        status_label.grid(row=0, column=2, sticky=tk.E, padx=(20, 0))
        
        header_frame.columnconfigure(2, weight=1)
        
        # Create notebook for tabs
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=5, pady=5)
        
        # Create tabs
        self.scan_tab = ttk.Frame(self.notebook, padding="10")
        self.dashboard_tab = ttk.Frame(self.notebook, padding="10")
        self.history_tab = ttk.Frame(self.notebook, padding="10")
        self.analysis_tab = ttk.Frame(self.notebook, padding="10")
        self.settings_tab = ttk.Frame(self.notebook, padding="10")
        
        self.notebook.add(self.scan_tab, text="🔍 Scan File")
        self.notebook.add(self.dashboard_tab, text="📊 Dashboard")
        self.notebook.add(self.history_tab, text="📋 History")
        self.notebook.add(self.analysis_tab, text="📈 Analysis")
        self.notebook.add(self.settings_tab, text="⚙️ Settings")
        
        # Setup each tab
        self.setup_scan_tab()
        self.setup_dashboard_tab()
        self.setup_history_tab()
        self.setup_analysis_tab()
        self.setup_settings_tab()
        
        # Bind tab change event
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
    
    def setup_scan_tab(self):
        """Setup the file scanning tab"""
        # Main frame with two columns
        scan_main_frame = ttk.Frame(self.scan_tab)
        scan_main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Left panel - File selection and controls
        left_panel = ttk.Frame(scan_main_frame, width=300)
        left_panel.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        left_panel.pack_propagate(False)
        
        # File selection frame
        file_frame = ttk.LabelFrame(left_panel, text="File Selection", padding="10")
        file_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(file_frame, text="Select a file to scan:").grid(row=0, column=0, sticky=tk.W, pady=(0, 5))
        
        file_input_frame = ttk.Frame(file_frame)
        file_input_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10))
        file_input_frame.columnconfigure(1, weight=1)
        
        self.file_path_var = tk.StringVar()
        file_entry = ttk.Entry(file_input_frame, textvariable=self.file_path_var)
        file_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(5, 5))
        
        browse_btn = ttk.Button(file_input_frame, text="Browse", command=self.browse_file)
        browse_btn.grid(row=0, column=2, padx=(5, 0))
        
        # Folder selection
        ttk.Label(file_frame, text="Or select a folder to scan:").grid(row=2, column=0, sticky=tk.W, pady=(10, 5))
        
        folder_input_frame = ttk.Frame(file_frame)
        folder_input_frame.grid(row=3, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10))
        folder_input_frame.columnconfigure(1, weight=1)
        
        self.folder_path_var = tk.StringVar()
        folder_entry = ttk.Entry(folder_input_frame, textvariable=self.folder_path_var)
        folder_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(5, 5))
        
        browse_folder_btn = ttk.Button(folder_input_frame, text="Browse", command=self.browse_folder)
        browse_folder_btn.grid(row=0, column=2, padx=(5, 0))
        
        # Model selection
        ttk.Label(file_frame, text="Select model:").grid(row=4, column=0, sticky=tk.W, pady=(10, 5))
        self.model_var = tk.StringVar()
        model_combo = ttk.Combobox(file_frame, textvariable=self.model_var, state="readonly")
        model_combo.grid(row=4, column=1, sticky=(tk.W, tk.E), padx=(5, 0), pady=(10, 5))
        model_combo.bind('<<ComboboxSelected>>', self.on_model_change)
        
        # Scan buttons
        button_frame = ttk.Frame(file_frame)
        button_frame.grid(row=5, column=0, columnspan=3, pady=(10, 0))
        
        self.scan_file_button = ttk.Button(button_frame, text="Scan File", command=self.scan_file, style='Accent.TButton')
        self.scan_file_button.pack(side=tk.LEFT, padx=(0, 5))
        
        self.scan_folder_button = ttk.Button(button_frame, text="Scan Folder", command=self.scan_folder, style='Secondary.TButton')
        self.scan_folder_button.pack(side=tk.LEFT)
        
        # Real-time protection frame
        protection_frame = ttk.LabelFrame(left_panel, text="Real-time Protection", padding="10")
        protection_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.realtime_var = tk.BooleanVar()
        realtime_check = ttk.Checkbutton(protection_frame, text="Enable real-time folder monitoring", 
                                        variable=self.realtime_var, command=self.toggle_realtime_protection)
        realtime_check.pack(anchor=tk.W, pady=(0, 5))
        
        ttk.Label(protection_frame, text="Monitor folder:").pack(anchor=tk.W, pady=(5, 0))
        
        monitor_frame = ttk.Frame(protection_frame)
        monitor_frame.pack(fill=tk.X, pady=(5, 0))
        monitor_frame.columnconfigure(0, weight=1)
        
        self.monitor_path_var = tk.StringVar(value=os.path.expanduser("~/Downloads"))
        monitor_entry = ttk.Entry(monitor_frame, textvariable=self.monitor_path_var)
        monitor_entry.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=(0, 5))
        
        monitor_btn = ttk.Button(monitor_frame, text="Browse", command=self.browse_monitor_folder)
        monitor_btn.grid(row=0, column=1)
        
        # Trust list frame
        trust_frame = ttk.LabelFrame(left_panel, text="Trust List", padding="10")
        trust_frame.pack(fill=tk.X)
        
        ttk.Button(trust_frame, text="Add Current File to Trust List", 
                  command=self.add_to_trust_list, style='Safe.TButton').pack(fill=tk.X, pady=(0, 5))
        
        ttk.Button(trust_frame, text="View Trust List", 
                  command=self.view_trust_list).pack(fill=tk.X)
        
        # Right panel - Results
        right_panel = ttk.Frame(scan_main_frame)
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # Results frame
        results_frame = ttk.LabelFrame(right_panel, text="Scan Results", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create notebook for results
        self.results_notebook = ttk.Notebook(results_frame)
        self.results_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Single file result tab
        single_result_tab = ttk.Frame(self.results_notebook)
        self.results_notebook.add(single_result_tab, text="Single File")
        
        self.result_text = scrolledtext.ScrolledText(single_result_tab, wrap=tk.WORD)
        self.result_text.pack(fill=tk.BOTH, expand=True)
        self.result_text.config(state=tk.DISABLED)
        
        # Batch results tab
        batch_result_tab = ttk.Frame(self.results_notebook)
        self.results_notebook.add(batch_result_tab, text="Batch Results")
        
        # Create treeview for batch results
        columns = ('file_name', 'result', 'confidence', 'file_size')
        self.batch_tree = ttk.Treeview(batch_result_tab, columns=columns, show='headings')
        
        # Define headings
        self.batch_tree.heading('file_name', text='File Name')
        self.batch_tree.heading('result', text='Result')
        self.batch_tree.heading('confidence', text='Confidence (%)')
        self.batch_tree.heading('file_size', text='Size')
        
        # Define columns
        self.batch_tree.column('file_name', width=200)
        self.batch_tree.column('result', width=100)
        self.batch_tree.column('confidence', width=100)
        self.batch_tree.column('file_size', width=100)
        
        # Add scrollbar
        batch_scrollbar = ttk.Scrollbar(batch_result_tab, orient=tk.VERTICAL, command=self.batch_tree.yview)
        self.batch_tree.configure(yscrollcommand=batch_scrollbar.set)
        
        # Pack tree and scrollbar
        self.batch_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        batch_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Context menu for batch results
        self.batch_menu = tk.Menu(self.batch_tree, tearoff=0)
        self.batch_menu.add_command(label="View Details", command=self.show_batch_details)
        self.batch_menu.add_command(label="Add to Trust List", command=self.add_batch_to_trust_list)
        self.batch_tree.bind("<Button-3>", self.show_batch_menu)
        
        # Configure grid weights
        file_frame.columnconfigure(1, weight=1)
    
    def setup_dashboard_tab(self):
        """Setup the dashboard tab"""
        # Create frames for dashboard
        stats_frame = ttk.Frame(self.dashboard_tab)
        stats_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Stats cards
        cards_data = [
            {"title": "Total Scans", "value": "0", "color": self.secondary_color},
            {"title": "Malicious Files", "value": "0", "color": self.warning_color},
            {"title": "Benign Files", "value": "0", "color": self.safe_color},
            {"title": "Detection Rate", "value": "0%", "color": self.accent_color}
        ]
        
        self.dashboard_cards = []
        for i, data in enumerate(cards_data):
            card = ttk.Frame(stats_frame, relief=tk.RAISED, borderwidth=1)
            card.grid(row=0, column=i, padx=(0, 10) if i < len(cards_data)-1 else 0, sticky=(tk.W, tk.E))
            stats_frame.columnconfigure(i, weight=1)
            
            title_label = ttk.Label(card, text=data["title"], font=('Segoe UI', 10))
            title_label.pack(pady=(10, 0))
            
            value_label = ttk.Label(card, text=data["value"], font=('Segoe UI', 16, 'bold'), foreground=data["color"])
            value_label.pack(pady=(5, 10))
            
            self.dashboard_cards.append(value_label)
        
        # Charts frame
        charts_frame = ttk.Frame(self.dashboard_tab)
        charts_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create matplotlib figure for dashboard
        self.dashboard_fig = Figure(figsize=(10, 6), dpi=100)
        self.dashboard_canvas = FigureCanvasTkAgg(self.dashboard_fig, charts_frame)
        self.dashboard_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Add toolbar
        toolbar = NavigationToolbar2Tk(self.dashboard_canvas, charts_frame)
        toolbar.update()
        
        # Initially display a message
        self.update_dashboard()
    
    def setup_history_tab(self):
        """Setup the scan history tab"""
        # History table
        columns = ('timestamp', 'file_name', 'result', 'confidence', 'file_size')
        self.history_tree = ttk.Treeview(self.history_tab, columns=columns, show='headings')
        
        # Define headings
        self.history_tree.heading('timestamp', text='Timestamp')
        self.history_tree.heading('file_name', text='File Name')
        self.history_tree.heading('result', text='Result')
        self.history_tree.heading('confidence', text='Confidence (%)')
        self.history_tree.heading('file_size', text='Size')
        
        # Define columns
        self.history_tree.column('timestamp', width=150)
        self.history_tree.column('file_name', width=200)
        self.history_tree.column('result', width=100)
        self.history_tree.column('confidence', width=100)
        self.history_tree.column('file_size', width=100)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(self.history_tab, orient=tk.VERTICAL, command=self.history_tree.yview)
        self.history_tree.configure(yscrollcommand=scrollbar.set)
        
        # Pack tree and scrollbar
        self.history_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Context menu
        self.history_menu = tk.Menu(self.history_tree, tearoff=0)
        self.history_menu.add_command(label="View Details", command=self.show_history_details)
        self.history_menu.add_command(label="Add to Trust List", command=self.add_history_to_trust_list)
        self.history_menu.add_command(label="Delete Entry", command=self.delete_history_entry)
        self.history_tree.bind("<Button-3>", self.show_history_menu)
    
    def setup_analysis_tab(self):
        """Setup the model analysis tab"""
        # Model performance frame
        perf_frame = ttk.LabelFrame(self.analysis_tab, text="Model Performance", padding="10")
        perf_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create matplotlib figure
        self.analysis_fig = Figure(figsize=(10, 8), dpi=100)
        self.analysis_canvas = FigureCanvasTkAgg(self.analysis_fig, perf_frame)
        self.analysis_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Add toolbar
        toolbar = NavigationToolbar2Tk(self.analysis_canvas, perf_frame)
        toolbar.update()
        
        # Initially display a message
        ax = self.analysis_fig.add_subplot(111)
        ax.text(0.5, 0.5, 'Train a model to see analysis', 
                horizontalalignment='center', verticalalignment='center',
                transform=ax.transAxes, fontsize=14)
        ax.set_axis_off()
        self.analysis_canvas.draw()
    
    def setup_settings_tab(self):
        """Setup the settings tab"""
        # Main frame with scrollbar
        settings_main_frame = ttk.Frame(self.settings_tab)
        settings_main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create canvas and scrollbar
        canvas = tk.Canvas(settings_main_frame)
        scrollbar = ttk.Scrollbar(settings_main_frame, orient=tk.VERTICAL, command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Training frame
        train_frame = ttk.LabelFrame(scrollable_frame, text="Model Training", padding="10")
        train_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(train_frame, text="Train New Model", command=self.train_model, style='Accent.TButton').pack(pady=5)
        ttk.Button(train_frame, text="Load Model", command=self.load_model).pack(pady=5)
        ttk.Button(train_frame, text="Save Model", command=self.save_model).pack(pady=5)
        
        # Data settings frame
        data_frame = ttk.LabelFrame(scrollable_frame, text="Data Settings", padding="10")
        data_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(data_frame, text="Synthetic samples:").grid(row=0, column=0, sticky=tk.W, pady=(0, 5))
        self.samples_var = tk.IntVar(value=1000)
        ttk.Spinbox(data_frame, from_=100, to=10000, increment=100, textvariable=self.samples_var, width=10).grid(row=0, column=1, sticky=tk.W, padx=(5, 0), pady=(0, 5))
        
        # Advanced settings frame
        advanced_frame = ttk.LabelFrame(scrollable_frame, text="Advanced Settings", padding="10")
        advanced_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Checkbutton(advanced_frame, text="Enable heuristic analysis", variable=tk.BooleanVar(value=True)).pack(anchor=tk.W)
        ttk.Checkbutton(advanced_frame, text="Enable cloud lookup", variable=tk.BooleanVar(value=False)).pack(anchor=tk.W)
        ttk.Checkbutton(advanced_frame, text="Enable automatic updates", variable=tk.BooleanVar(value=True)).pack(anchor=tk.W)
        
        # Database management frame
        db_frame = ttk.LabelFrame(scrollable_frame, text="Database Management", padding="10")
        db_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(db_frame, text="Clear Scan History", command=self.clear_history).pack(pady=2)
        ttk.Button(db_frame, text="Export Scan Results", command=self.export_results).pack(pady=2)
        ttk.Button(db_frame, text="Import Scan Results", command=self.import_results).pack(pady=2)
        
        # Info frame
        info_frame = ttk.LabelFrame(scrollable_frame, text="System Information", padding="10")
        info_frame.pack(fill=tk.X)
        
        info_text = f"""
        Advanced Malware Detection AI System v2.0
        
        Features:
        - Multiple machine learning models (Random Forest, Gradient Boosting, SVM, Isolation Forest)
        - Real-time folder monitoring
        - Trust list management
        - Comprehensive PE file analysis
        - File hash calculation (SHA256)
        - Import table analysis for suspicious APIs
        - Database storage for scan history
        - Advanced visualization and reporting
        
        File types supported: Windows PE files (EXE, DLL, SYS)
        
        System Status: Ready
        """
        
        info_label = ttk.Label(info_frame, text=info_text, justify=tk.LEFT)
        info_label.pack(anchor=tk.W)
    
    def on_tab_changed(self, event):
        """Handle tab change events"""
        current_tab = self.notebook.tab(self.notebook.select(), "text")
        
        if current_tab == "📋 History":
            self.load_scan_history()
        elif current_tab == "📊 Dashboard":
            self.update_dashboard()
    
    def browse_file(self):
        """Open file dialog to select a file"""
        file_path = filedialog.askopenfilename(
            title="Select a file to scan",
            filetypes=[("Executable files", "*.exe *.dll *.sys"), ("All files", "*.*")]
        )
        if file_path:
            self.file_path_var.set(file_path)
    
    def browse_folder(self):
        """Open folder dialog to select a folder"""
        folder_path = filedialog.askdirectory(title="Select a folder to scan")
        if folder_path:
            self.folder_path_var.set(folder_path)
    
    def browse_monitor_folder(self):
        """Open folder dialog to select a monitor folder"""
        folder_path = filedialog.askdirectory(title="Select a folder to monitor")
        if folder_path:
            self.monitor_path_var.set(folder_path)
    
    def on_model_change(self, event):
        """Handle model selection change"""
        model_name = self.model_var.get()
        if model_name and self.detector.set_model(model_name):
            self.status_var.set(f"Model changed to: {model_name}")
    
    def scan_file(self):
        """Scan the selected file"""
        file_path = self.file_path_var.get()
        if not file_path or not os.path.isfile(file_path):
            messagebox.showerror("Error", "Please select a valid file to scan.")
            return
        
        # Disable button during scan
        self.scan_file_button.config(state=tk.DISABLED)
        self.status_var.set("Scanning file...")
        
        # Switch to single result tab
        self.results_notebook.select(0)
        
        # Run scan in thread to prevent GUI freezing
        threading.Thread(target=self._perform_scan, args=(file_path,), daemon=True).start()
    
    def scan_folder(self):
        """Scan all files in the selected folder"""
        folder_path = self.folder_path_var.get()
        if not folder_path or not os.path.isdir(folder_path):
            messagebox.showerror("Error", "Please select a valid folder to scan.")
            return
        
        # Get all executable files in folder
        exe_files = []
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                if file.lower().endswith(('.exe', '.dll', '.sys')):
                    exe_files.append(os.path.join(root, file))
        
        if not exe_files:
            messagebox.showinfo("Info", "No executable files found in the selected folder.")
            return
        
        # Disable button during scan
        self.scan_folder_button.config(state=tk.DISABLED)
        self.status_var.set(f"Scanning {len(exe_files)} files...")
        
        # Switch to batch result tab
        self.results_notebook.select(1)
        
        # Clear previous results
        for item in self.batch_tree.get_children():
            self.batch_tree.delete(item)
        
        # Run scan in thread to prevent GUI freezing
        threading.Thread(target=self._perform_folder_scan, args=(exe_files,), daemon=True).start()
    
    def _perform_scan(self, file_path):
        """Perform the actual file scan (run in thread)"""
        try:
            result = self.detector.predict(file_path)
            
            # Save to database
            self.detector.db.save_scan_result(result)
            
            # Update GUI in main thread
            self.root.after(0, self._display_scan_result, result)
            
        except Exception as e:
            self.root.after(0, lambda: messagebox.showerror("Error", f"Scan failed: {str(e)}"))
            self.root.after(0, lambda: self.status_var.set("Scan failed"))
            self.root.after(0, lambda: self.scan_file_button.config(state=tk.NORMAL))
    
    def _perform_folder_scan(self, file_paths):
        """Perform scan on multiple files (run in thread)"""
        self.current_scan_results = []
        
        for i, file_path in enumerate(file_paths):
            try:
                result = self.detector.predict(file_path)
                self.current_scan_results.append(result)
                
                # Save to database
                self.detector.db.save_scan_result(result)
                
                # Update progress in GUI
                progress = (i + 1) / len(file_paths) * 100
                self.root.after(0, lambda: self.status_var.set(f"Scanning... {progress:.1f}%"))
                
                # Add to batch tree in GUI
                self.root.after(0, self._add_batch_result, result)
                
            except Exception as e:
                print(f"Error scanning {file_path}: {str(e)}")
        
        # Update GUI when done
        self.root.after(0, lambda: self.status_var.set(f"Folder scan completed: {len(self.current_scan_results)} files scanned"))
        self.root.after(0, lambda: self.scan_folder_button.config(state=tk.NORMAL))
    
    def _add_batch_result(self, result):
        """Add a result to the batch treeview"""
        item_id = self.batch_tree.insert('', 'end', values=(
            result['file_name'],
            result['result'],
            f"{result['confidence']:.2f}",
            f"{result['file_size'] / 1024:.1f} KB"
        ))
        
        # Color code based on result
        if result['result'] == 'Malicious':
            self.batch_tree.set(item_id, 'result', 'Malicious')
            self.batch_tree.item(item_id, tags=('malicious',))
        else:
            self.batch_tree.item(item_id, tags=('benign',))
        
        # Configure tags for coloring
        self.batch_tree.tag_configure('malicious', foreground='red')
        self.batch_tree.tag_configure('benign', foreground='green')
    
    def _display_scan_result(self, result):
        """Display the scan result in the GUI"""
        if "error" in result:
            self.result_text.config(state=tk.NORMAL)
            self.result_text.delete(1.0, tk.END)
            self.result_text.insert(tk.END, f"Error: {result['error']}")
            self.result_text.config(state=tk.DISABLED)
            self.status_var.set("Scan completed with errors")
        else:
            # Format result text
            trust_note = " (Trust List)" if result.get('trust_list', False) else ""
            result_text = f"""
╔══════════════════════════════════════════════════════════════╗
║                     SCAN RESULT{trust_note: <15}                   ║
╠══════════════════════════════════════════════════════════════╣
║ File: {result['file_name']: <50} ║
║ Path: {result['file_path']: <50} ║
║ Size: {result['file_size']: <10} bytes                         ║
║ Hash: {result['file_hash']: <50} ║
║ Time: {result['timestamp']: <50} ║
╠══════════════════════════════════════════════════════════════╣
║ Result:    {result['result']: <20} Confidence: {result['confidence']:6.2f}% ║
╚══════════════════════════════════════════════════════════════╝

Detailed Features:
"""
            for key, value in result['features'].items():
                if key not in ['FileHash']:  # Skip hash in feature display
                    result_text += f"  {key:25}: {value}\n"
            
            # Update result text widget
            self.result_text.config(state=tk.NORMAL)
            self.result_text.delete(1.0, tk.END)
            self.result_text.insert(tk.END, result_text)
            self.result_text.config(state=tk.DISABLED)
            
            # Add to history
            self.scan_history.append(result)
            self.update_history_display()
            
            self.status_var.set("Scan completed successfully")
        
        # Re-enable scan button
        self.scan_file_button.config(state=tk.NORMAL)
    
    def load_scan_history(self):
        """Load scan history from database"""
        self.scan_history = self.detector.db.get_scan_history(100)
        self.update_history_display()
        self.update_dashboard()
    
    def update_history_display(self):
        """Update the history treeview with current scan history"""
        # Clear current items
        for item in self.history_tree.get_children():
            self.history_tree.delete(item)
        
        # Add items from history
        for i, scan in enumerate(self.scan_history):
            item_id = self.history_tree.insert('', 'end', values=(
                scan['timestamp'],
                scan['file_name'],
                scan['result'],
                f"{scan['confidence']:.2f}",
                f"{scan['file_size'] / 1024:.1f} KB"
            ))
            
            # Color code based on result
            if scan['result'] == 'Malicious':
                self.history_tree.item(item_id, tags=('malicious',))
            else:
                self.history_tree.item(item_id, tags=('benign',))
        
        # Configure tags for coloring
        self.history_tree.tag_configure('malicious', foreground='red')
        self.history_tree.tag_configure('benign', foreground='green')
    
    def update_dashboard(self):
        """Update the dashboard with current statistics"""
        if not self.scan_history:
            return
        
        # Calculate statistics
        total_scans = len(self.scan_history)
        malicious_count = sum(1 for scan in self.scan_history if scan['result'] == 'Malicious')
        benign_count = total_scans - malicious_count
        detection_rate = (malicious_count / total_scans * 100) if total_scans > 0 else 0
        
        # Update card values
        self.dashboard_cards[0].config(text=str(total_scans))
        self.dashboard_cards[1].config(text=str(malicious_count))
        self.dashboard_cards[2].config(text=str(benign_count))
        self.dashboard_cards[3].config(text=f"{detection_rate:.1f}%")
        
        # Update charts
        self.dashboard_fig.clear()
        
        # Create subplots
        ax1 = self.dashboard_fig.add_subplot(221)  # Scan results pie chart
        ax2 = self.dashboard_fig.add_subplot(222)  # Confidence distribution
        ax3 = self.dashboard_fig.add_subplot(223)  # File size distribution
        ax4 = self.dashboard_fig.add_subplot(224)  # Timeline of scans
        
        # Plot scan results pie chart
        labels = ['Benign', 'Malicious']
        sizes = [benign_count, malicious_count]
        colors = [self.safe_color, self.warning_color]
        ax1.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=90)
        ax1.set_title('Scan Results Distribution')
        ax1.axis('equal')
        
        # Plot confidence distribution
        malicious_confidences = [scan['confidence'] for scan in self.scan_history if scan['result'] == 'Malicious']
        benign_confidences = [scan['confidence'] for scan in self.scan_history if scan['result'] == 'Benign']
        
        if malicious_confidences:
            ax2.hist(malicious_confidences, bins=10, alpha=0.7, color=self.warning_color, label='Malicious')
        if benign_confidences:
            ax2.hist(benign_confidences, bins=10, alpha=0.7, color=self.safe_color, label='Benign')
        ax2.set_xlabel('Confidence (%)')
        ax2.set_ylabel('Count')
        ax2.set_title('Confidence Distribution')
        ax2.legend()
        
        # Plot file size distribution
        malicious_sizes = [scan['file_size']/1024 for scan in self.scan_history if scan['result'] == 'Malicious']
        benign_sizes = [scan['file_size']/1024 for scan in self.scan_history if scan['result'] == 'Benign']
        
        if malicious_sizes:
            ax3.hist(malicious_sizes, bins=10, alpha=0.7, color=self.warning_color, label='Malicious')
        if benign_sizes:
            ax3.hist(benign_sizes, bins=10, alpha=0.7, color=self.safe_color, label='Benign')
        ax3.set_xlabel('File Size (KB)')
        ax3.set_ylabel('Count')
        ax3.set_title('File Size Distribution')
        ax3.legend()
        
        # Plot timeline of scans
        dates = [datetime.strptime(scan['timestamp'], "%Y-%m-%d %H:%M:%S") for scan in self.scan_history]
        dates.sort()
        date_counts = {}
        for date in dates:
            date_str = date.strftime("%Y-%m-%d")
            date_counts[date_str] = date_counts.get(date_str, 0) + 1
        
        ax4.plot(list(date_counts.keys()), list(date_counts.values()), marker='o', color=self.accent_color)
        ax4.set_xlabel('Date')
        ax4.set_ylabel('Scans')
        ax4.set_title('Scan Activity Timeline')
        plt.setp(ax4.xaxis.get_majorticklabels(), rotation=45)
        
        # Adjust layout and draw
        self.dashboard_fig.tight_layout()
        self.dashboard_canvas.draw()
    
    def show_history_menu(self, event):
        """Show context menu for history items"""
        item = self.history_tree.identify_row(event.y)
        if item:
            self.history_tree.selection_set(item)
            self.history_menu.post(event.x_root, event.y_root)
    
    def show_batch_menu(self, event):
        """Show context menu for batch results"""
        item = self.batch_tree.identify_row(event.y)
        if item:
            self.batch_tree.selection_set(item)
            self.batch_menu.post(event.x_root, event.y_root)
    
    def show_history_details(self):
        """Show details of selected history item"""
        selection = self.history_tree.selection()
        if not selection:
            return
        
        item_idx = self.history_tree.index(selection[0])
        scan = self.scan_history[item_idx]
        self._show_scan_details(scan)
    
    def show_batch_details(self):
        """Show details of selected batch result"""
        selection = self.batch_tree.selection()
        if not selection:
            return
        
        item_idx = self.batch_tree.index(selection[0])
        scan = self.current_scan_results[item_idx]
        self._show_scan_details(scan)
    
    def _show_scan_details(self, scan):
        """Show detailed scan results"""
        # Create details window
        details_win = tk.Toplevel(self.root)
        details_win.title("Scan Details")
        details_win.geometry("700x600")
        
        # Create text widget
        text_widget = scrolledtext.ScrolledText(details_win, wrap=tk.WORD)
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Format details text
        trust_note = " (Trust List)" if scan.get('trust_list', False) else ""
        details_text = f"""
╔══════════════════════════════════════════════════════════════╗
║                     SCAN DETAILS{trust_note: <12}                   ║
╠══════════════════════════════════════════════════════════════╣
║ File: {scan['file_name']: <50} ║
║ Path: {scan['file_path']: <50} ║
║ Size: {scan['file_size']: <10} bytes                         ║
║ Hash: {scan['file_hash']: <50} ║
║ Time: {scan['timestamp']: <50} ║
╠══════════════════════════════════════════════════════════════╣
║ Result:    {scan['result']: <20} Confidence: {scan['confidence']:6.2f}% ║
╚══════════════════════════════════════════════════════════════╝

Detailed Features:
"""
        for key, value in scan['features'].items():
            if key not in ['FileHash']:
                details_text += f"  {key:25}: {value}\n"
        
        # Insert text
        text_widget.insert(tk.END, details_text)
        text_widget.config(state=tk.DISABLED)
        
        # Add buttons
        button_frame = ttk.Frame(details_win)
        button_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        ttk.Button(button_frame, text="Add to Trust List", 
                  command=lambda: self.add_to_trust_list(scan['file_hash'])).pack(side=tk.LEFT)
        
        ttk.Button(button_frame, text="Close", 
                  command=details_win.destroy).pack(side=tk.RIGHT)
    
    def add_to_trust_list(self, file_hash=None):
        """Add current file to trust list"""
        if file_hash is None:
            file_path = self.file_path_var.get()
            if not file_path:
                messagebox.showerror("Error", "No file selected.")
                return
            file_hash = calculate_file_hash(file_path)
        
        if file_hash and self.detector.add_to_trust_list(file_hash):
            messagebox.showinfo("Success", "File added to trust list.")
        else:
            messagebox.showerror("Error", "Failed to add file to trust list.")
    
    def add_history_to_trust_list(self):
        """Add selected history item to trust list"""
        selection = self.history_tree.selection()
        if not selection:
            return
        
        item_idx = self.history_tree.index(selection[0])
        scan = self.scan_history[item_idx]
        
        if self.detector.add_to_trust_list(scan['file_hash']):
            messagebox.showinfo("Success", "File added to trust list.")
        else:
            messagebox.showerror("Error", "Failed to add file to trust list.")
    
    def add_batch_to_trust_list(self):
        """Add selected batch result to trust list"""
        selection = self.batch_tree.selection()
        if not selection:
            return
        
        item_idx = self.batch_tree.index(selection[0])
        scan = self.current_scan_results[item_idx]
        
        if self.detector.add_to_trust_list(scan['file_hash']):
            messagebox.showinfo("Success", "File added to trust list.")
        else:
            messagebox.showerror("Error", "Failed to add file to trust list.")
    
    def view_trust_list(self):
        """View the trust list"""
        conn = sqlite3.connect(self.detector.db.db_path)
        cursor = conn.cursor()
        
        cursor.execute('SELECT file_hash, reason, added_date FROM file_trust_list ORDER BY added_date DESC')
        results = cursor.fetchall()
        conn.close()
        
        # Create trust list window
        trust_win = tk.Toplevel(self.root)
        trust_win.title("Trust List")
        trust_win.geometry("600x400")
        
        # Create treeview
        columns = ('file_hash', 'reason', 'added_date')
        tree = ttk.Treeview(trust_win, columns=columns, show='headings')
        
        # Define headings
        tree.heading('file_hash', text='File Hash')
        tree.heading('reason', text='Reason')
        tree.heading('added_date', text='Added Date')
        
        # Define columns
        tree.column('file_hash', width=200)
        tree.column('reason', width=200)
        tree.column('added_date', width=150)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(trust_win, orient=tk.VERTICAL, command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)
        
        # Pack tree and scrollbar
        tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Add items
        for result in results:
            tree.insert('', 'end', values=result)
    
    def delete_history_entry(self):
        """Delete selected history entry"""
        selection = self.history_tree.selection()
        if not selection:
            return
        
        item_idx = self.history_tree.index(selection[0])
        file_hash = self.scan_history[item_idx]['file_hash']
        
        # Remove from database
        conn = sqlite3.connect(self.detector.db.db_path)
        cursor = conn.cursor()
        cursor.execute('DELETE FROM scan_history WHERE file_hash = ?', (file_hash,))
        conn.commit()
        conn.close()
        
        # Remove from local history
        self.scan_history.pop(item_idx)
        self.update_history_display()
        self.update_dashboard()
    
    def toggle_realtime_protection(self):
        """Toggle real-time folder monitoring"""
        if self.realtime_var.get():
            monitor_path = self.monitor_path_var.get()
            if not os.path.isdir(monitor_path):
                messagebox.showerror("Error", "Please select a valid folder to monitor.")
                self.realtime_var.set(False)
                return
            
            self.status_var.set(f"Real-time protection enabled for {monitor_path}")
            # Start monitoring thread
            threading.Thread(target=self._monitor_folder, args=(monitor_path,), daemon=True).start()
        else:
            self.status_var.set("Real-time protection disabled")
    
    def _monitor_folder(self, folder_path):
        """Monitor folder for new files (run in thread)"""
        known_files = set()
        
        while self.realtime_var.get():
            try:
                current_files = set()
                for root, dirs, files in os.walk(folder_path):
                    for file in files:
                        if file.lower().endswith(('.exe', '.dll', '.sys')):
                            file_path = os.path.join(root, file)
                            current_files.add(file_path)
                
                # Check for new files
                new_files = current_files - known_files
                for file_path in new_files:
                    try:
                        result = self.detector.predict(file_path)
                        self.detector.db.save_scan_result(result)
                        
                        # Show alert if malicious
                        if result['result'] == 'Malicious':
                            self.root.after(0, self._show_realtime_alert, result)
                    
                    except Exception as e:
                        print(f"Error scanning {file_path}: {str(e)}")
                
                known_files = current_files
                time.sleep(5)  # Check every 5 seconds
                
            except Exception as e:
                print(f"Error in folder monitoring: {str(e)}")
                time.sleep(10)
    
    def _show_realtime_alert(self, result):
        """Show real-time alert for malicious files"""
        alert_win = tk.Toplevel(self.root)
        alert_win.title("🚨 Malware Detected!")
        alert_win.geometry("500x300")
        alert_win.configure(background=self.warning_color)
        
        # Make alert modal
        alert_win.transient(self.root)
        alert_win.grab_set()
        
        # Alert content
        content_frame = ttk.Frame(alert_win, padding="20")
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(content_frame, text="🚨 MALWARE DETECTED!", 
                 font=('Segoe UI', 16, 'bold'), foreground='white', 
                 background=self.warning_color).pack(pady=(0, 20))
        
        ttk.Label(content_frame, text=f"File: {result['file_name']}", 
                 background=self.warning_color, foreground='white').pack(anchor=tk.W)
        
        ttk.Label(content_frame, text=f"Location: {result['file_path']}", 
                 background=self.warning_color, foreground='white').pack(anchor=tk.W)
        
        ttk.Label(content_frame, text=f"Confidence: {result['confidence']:.2f}%", 
                 background=self.warning_color, foreground='white').pack(anchor=tk.W)
        
        # Buttons
        button_frame = ttk.Frame(content_frame)
        button_frame.pack(fill=tk.X, pady=(20, 0))
        
        ttk.Button(button_frame, text="Quarantine", 
                  command=lambda: self._quarantine_file(result['file_path'], alert_win),
                  style='Warning.TButton').pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Button(button_frame, text="Ignore", 
                  command=alert_win.destroy).pack(side=tk.LEFT)
        
        ttk.Button(button_frame, text="Add to Trust List", 
                  command=lambda: self._add_and_close(result['file_hash'], alert_win),
                  style='Safe.TButton').pack(side=tk.RIGHT)
    
    def _quarantine_file(self, file_path, alert_win):
        """Quarantine a detected file"""
        try:
            # Create quarantine directory if it doesn't exist
            quarantine_dir = os.path.join(os.path.dirname(__file__), "Quarantine")
            os.makedirs(quarantine_dir, exist_ok=True)
            
            # Move file to quarantine
            file_name = os.path.basename(file_path)
            quarantine_path = os.path.join(quarantine_dir, file_name)
            
            # Ensure unique filename
            counter = 1
            while os.path.exists(quarantine_path):
                name, ext = os.path.splitext(file_name)
                quarantine_path = os.path.join(quarantine_dir, f"{name}_{counter}{ext}")
                counter += 1
            
            os.rename(file_path, quarantine_path)
            messagebox.showinfo("Success", f"File quarantined: {quarantine_path}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to quarantine file: {str(e)}")
        
        alert_win.destroy()
    
    def _add_and_close(self, file_hash, alert_win):
        """Add file to trust list and close alert"""
        if self.detector.add_to_trust_list(file_hash):
            messagebox.showinfo("Success", "File added to trust list.")
        else:
            messagebox.showerror("Error", "Failed to add file to trust list.")
        
        alert_win.destroy()
    
    def train_model(self):
        """Train a new model"""
        # Show progress
        self.status_var.set("Training model...")
        
        # Run training in thread
        threading.Thread(target=self._perform_training, daemon=True).start()
    
    def _perform_training(self):
        """Perform model training (run in thread)"""
        try:
            # Create synthetic data
            samples = self.samples_var.get()
            features_df, labels = self.detector.create_synthetic_data(samples)
            
            # Train models
            results, X_test, y_test = self.detector.train_models(features_df, labels)
            
            # Update model selection
            model_names = list(self.detector.models.keys())
            self.root.after(0, lambda: self.model_var.set(model_names[0]))
            self.root.after(0, lambda: self.model_var.config(values=model_names))
            
            # Update analysis tab
            self.root.after(0, self._update_analysis, results, X_test, y_test)
            
            self.root.after(0, lambda: self.status_var.set("Model training completed"))
            self.root.after(0, lambda: messagebox.showinfo("Success", "Model training completed successfully!"))
            
        except Exception as e:
            self.root.after(0, lambda: messagebox.showerror("Error", f"Training failed: {str(e)}"))
            self.root.after(0, lambda: self.status_var.set("Training failed"))
    
    def _update_analysis(self, results, X_test, y_test):
        """Update the analysis tab with model performance data"""
        # Clear previous figure
        self.analysis_fig.clear()
        
        # Create subplots
        ax1 = self.analysis_fig.add_subplot(221)  # Accuracy comparison
        ax2 = self.analysis_fig.add_subplot(222)  # Confusion matrix for first model
        ax3 = self.analysis_fig.add_subplot(223)  # Feature importance
        ax4 = self.analysis_fig.add_subplot(224)  # ROC curve
        
        # Plot accuracy comparison
        model_names = list(results.keys())
        train_scores = [results[name]['train_score'] for name in model_names]
        test_scores = [results[name]['test_score'] for name in model_names]
        cv_scores = [results[name]['cv_score'] or 0 for name in model_names if name != 'Isolation Forest']
        
        x = np.arange(len(model_names))
        width = 0.25
        
        ax1.bar(x - width, train_scores, width, label='Training', color=self.secondary_color)
        ax1.bar(x, test_scores, width, label='Testing', color=self.accent_color)
        
        # Add CV scores for models that have them
        if any(cv_scores):
            ax1.bar(x + width, [results[name]['cv_score'] or 0 for name in model_names], width, label='CV', color=self.safe_color)
        
        ax1.set_xlabel('Models')
        ax1.set_ylabel('Accuracy')
        ax1.set_title('Model Performance Comparison')
        ax1.set_xticks(x)
        ax1.set_xticklabels(model_names, rotation=45)
        ax1.legend()
        ax1.set_ylim(0, 1)
        
        # Plot confusion matrix for the first model
        first_model = model_names[0]
        cm = confusion_matrix(y_test, results[first_model]['y_pred'])
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', ax=ax2,
                   xticklabels=['Benign', 'Malicious'], 
                   yticklabels=['Benign', 'Malicious'])
        ax2.set_xlabel('Predicted')
        ax2.set_ylabel('Actual')
        ax2.set_title(f'Confusion Matrix - {first_model}')
        
        # Plot feature importance for the first model (if available)
        if hasattr(results[first_model]['model'], 'feature_importances_'):
            importances = results[first_model]['model'].feature_importances_
            indices = np.argsort(importances)[::-1]
            features = self.detector.feature_columns
            
            ax3.bar(range(10), importances[indices][:10], color=self.accent_color)
            ax3.set_xlabel('Feature Importance')
            ax3.set_title('Top 10 Feature Importances')
            ax3.set_xticks(range(10))
            ax3.set_xticklabels([features[i] for i in indices[:10]], rotation=45)
        else:
            ax3.text(0.5, 0.5, 'Feature importance not available', 
                    horizontalalignment='center', verticalalignment='center',
                    transform=ax3.transAxes)
            ax3.set_axis_off()
        
        # Plot ROC curve for models that support probability
        ax4.plot([0, 1], [0, 1], 'k--', label='Random')
        for name, result in results.items():
            if result['y_proba'] is not None:
                fpr, tpr, _ = roc_curve(y_test, result['y_proba'])
                roc_auc = auc(fpr, tpr)
                ax4.plot(fpr, tpr, label=f'{name} (AUC = {roc_auc:.2f})')
        
        ax4.set_xlabel('False Positive Rate')
        ax4.set_ylabel('True Positive Rate')
        ax4.set_title('ROC Curves')
        ax4.legend(loc='lower right')
        
        # Adjust layout and draw
        self.analysis_fig.tight_layout()
        self.analysis_canvas.draw()
    
    def load_model(self):
        """Load a trained model from file"""
        file_path = filedialog.askopenfilename(
            title="Select model file",
            filetypes=[("Model files", "*.model"), ("All files", "*.*")]
        )
        if file_path:
            try:
                self.detector.load_model(file_path)
                
                # Update model selection
                model_names = list(self.detector.models.keys())
                self.model_var.set(self.detector.current_model)
                self.model_var.config(values=model_names)
                
                self.status_var.set(f"Model loaded from {file_path}")
                messagebox.showinfo("Success", "Model loaded successfully!")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load model: {str(e)}")
    
    def save_model(self):
        """Save the current model to file"""
        if not self.detector.models:
            messagebox.showerror("Error", "No model to save. Please train a model first.")
            return
        
        file_path = filedialog.asksaveasfilename(
            title="Save model file",
            defaultextension=".model",
            filetypes=[("Model files", "*.model"), ("All files", "*.*")]
        )
        if file_path:
            try:
                self.detector.save_model(file_path)
                self.status_var.set(f"Model saved to {file_path}")
                messagebox.showinfo("Success", "Model saved successfully!")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save model: {str(e)}")
    
    def clear_history(self):
        """Clear scan history from database"""
        if messagebox.askyesno("Confirm", "Are you sure you want to clear all scan history?"):
            conn = sqlite3.connect(self.detector.db.db_path)
            cursor = conn.cursor()
            cursor.execute('DELETE FROM scan_history')
            conn.commit()
            conn.close()
            
            self.scan_history = []
            self.update_history_display()
            self.update_dashboard()
            messagebox.showinfo("Success", "Scan history cleared.")
    
    def export_results(self):
        """Export scan results to CSV"""
        file_path = filedialog.asksaveasfilename(
            title="Export scan results",
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if file_path:
            try:
                # Get all scan results
                conn = sqlite3.connect(self.detector.db.db_path)
                df = pd.read_sql_query('SELECT * FROM scan_history', conn)
                conn.close()
                
                # Export to CSV
                df.to_csv(file_path, index=False)
                messagebox.showinfo("Success", f"Results exported to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export results: {str(e)}")
    
    def import_results(self):
        """Import scan results from CSV"""
        file_path = filedialog.askopenfilename(
            title="Import scan results",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if file_path:
            try:
                # Read CSV
                df = pd.read_csv(file_path)
                
                # Import to database
                conn = sqlite3.connect(self.detector.db.db_path)
                df.to_sql('scan_history', conn, if_exists='append', index=False)
                conn.close()
                
                # Reload history
                self.load_scan_history()
                messagebox.showinfo("Success", "Results imported successfully.")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to import results: {str(e)}")
    
    def load_or_train_model(self):
        """Try to load a model or train a new one on startup"""
        # Try to load a default model
        default_model = "malware_detector.model"
        if os.path.exists(default_model):
            try:
                self.detector.load_model(default_model)
                
                # Update model selection
                model_names = list(self.detector.models.keys())
                self.model_var.set(self.detector.current_model)
                self.model_var.config(values=model_names)
                
                self.status_var.set("Default model loaded")
                return
            except:
                pass
        
        # If no model found, train a new one
        self.status_var.set("Training default model...")
        threading.Thread(target=self._perform_training, daemon=True).start()

# Main application
if __name__ == "__main__":
    root = tk.Tk()
    app = MalwareDetectorApp(root)
    root.mainloop()
